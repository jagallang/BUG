import 'dart:async';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import '../../../auth/domain/entities/user_entity.dart';

class FirebaseAuthService {
  final FirebaseAuth _firebaseAuth;
  final GoogleSignIn _googleSignIn;
  final FirebaseFirestore _firestore;
  
  // Mock 데이터 저장용 메모리 캐시
  static final Map<String, UserEntity> _mockUserCache = {};

  // Firebase 초기화 상태 확인
  bool get _isFirebaseInitialized {
    try {
      Firebase.apps.isNotEmpty;
      return true;
    } catch (e) {
      return false;
    }
  }

  FirebaseAuthService({
    FirebaseAuth? firebaseAuth,
    GoogleSignIn? googleSignIn,
    FirebaseFirestore? firestore,
  })  : _firebaseAuth = firebaseAuth ?? FirebaseAuth.instance,
        _googleSignIn = googleSignIn ?? GoogleSignIn(),
        _firestore = firestore ?? FirebaseFirestore.instance {
    
    // Firebase가 초기화된 경우에만 Firebase Auth 스트림 설정
    if (_isFirebaseInitialized) {
      try {
        // Firebase Auth와 Mock Auth 스트림을 결합
        _combinedAuthStream = _firebaseAuth.authStateChanges().transform(
          StreamTransformer.fromHandlers(
            handleData: (User? firebaseUser, sink) {
              // Mock 사용자가 있으면 Mock 사용자를 우선 반환
              if (_mockCurrentUser != null) {
                sink.add(_mockCurrentUser);
              } else {
                sink.add(firebaseUser);
              }
            },
          ),
        );
      } catch (e) {
        // Firebase 오류 시 Mock 전용 스트림 사용
        _combinedAuthStream = _mockAuthController.stream;
      }
    } else {
      // Firebase가 초기화되지 않은 경우 Mock 전용 스트림 사용
      _combinedAuthStream = _mockAuthController.stream;
    }
    
    // Mock auth controller의 이벤트도 처리
    _mockAuthController.stream.listen((User? mockUser) {
      // Mock 스트림이 별도로 필요하지 않음, 위에서 처리됨
    });
  }

  User? get currentUser {
    // Mock 사용자가 있는 경우 반환
    if (_mockCurrentUser != null) {
      return _mockCurrentUser;
    }
    // Firebase가 초기화된 경우에만 Firebase 사용자 반환
    if (_isFirebaseInitialized) {
      try {
        return _firebaseAuth.currentUser;
      } catch (e) {
        return null;
      }
    }
    return null;
  }

  Stream<User?> get authStateChanges {
    // Mock과 실제 Firebase Auth 스트림을 결합
    return _combinedAuthStream;
  }
  
  // Mock 현재 사용자
  static User? _mockCurrentUser;
  
  // Mock auth state stream controller
  static final _mockAuthController = StreamController<User?>.broadcast();
  
  // 결합된 auth 스트림
  late final Stream<User?> _combinedAuthStream;

  Future<UserCredential?> signInWithGoogle() async {
    try {
      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
      
      if (googleUser == null) {
        return null;
      }

      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;

      final credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );

      final userCredential = await _firebaseAuth.signInWithCredential(credential);
      
      if (userCredential.user != null) {
        await _updateLastLoginTime(userCredential.user!.uid);
      }
      
      return userCredential;
    } catch (e) {
      rethrow;
    }
  }

  Future<UserCredential> signUpWithEmailAndPassword({
    required String email,
    required String password,
    required String displayName,
    required UserType userType,
    required String country,
    String? phoneNumber,
  }) async {
    try {
      final userCredential = await _firebaseAuth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );

      final user = userCredential.user;
      if (user != null) {
        await user.updateDisplayName(displayName);
        
        final now = DateTime.now();
        final userEntity = UserEntity(
          uid: user.uid,
          email: email,
          displayName: displayName,
          photoUrl: user.photoURL,
          userType: userType,
          phoneNumber: phoneNumber,
          country: country,
          timezone: DateTime.now().timeZoneName,
          createdAt: now,
          updatedAt: now,
          lastLoginAt: now,
        );

        await _createUserDocument(userEntity);
      }

      return userCredential;
    } catch (e) {
      rethrow;
    }
  }

  Future<UserCredential> signInWithEmailAndPassword({
    required String email,
    required String password,
  }) async {
    try {
      // Mock 로그인 계정 처리 (Firestore API 미활성화 상태에서)
      if (await _isMockAccount(email)) {
        return await _mockSignIn(email, password);
      }
      
      final userCredential = await _firebaseAuth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      if (userCredential.user != null) {
        await _updateLastLoginTime(userCredential.user!.uid);
      }
      
      return userCredential;
    } catch (e) {
      rethrow;
    }
  }

  Future<void> sendPasswordResetEmail(String email) async {
    try {
      await _firebaseAuth.sendPasswordResetEmail(email: email);
    } catch (e) {
      rethrow;
    }
  }

  Future<void> signOut() async {
    try {
      // Mock 사용자 로그아웃
      if (_mockCurrentUser != null) {
        _mockCurrentUser = null;
        _mockAuthController.add(null);
      }
      
      await Future.wait([
        _firebaseAuth.signOut(),
        _googleSignIn.signOut(),
      ]);
    } catch (e) {
      // Firebase 로그아웃 실패해도 Mock은 로그아웃 처리
      if (_mockCurrentUser != null) {
        _mockCurrentUser = null;
        _mockAuthController.add(null);
      }
      rethrow;
    }
  }

  Future<UserEntity?> getUserData(String uid) async {
    try {
      // Mock 캐시에서 먼저 확인
      if (_mockUserCache.containsKey(uid)) {
        return _mockUserCache[uid];
      }
      
      // Firebase가 초기화된 경우에만 Firestore에서 조회
      if (_isFirebaseInitialized) {
        try {
          final doc = await _firestore.collection('users').doc(uid).get();
          
          if (doc.exists && doc.data() != null) {
            return UserEntity.fromFirestore(uid, doc.data()!);
          }
        } catch (e) {
          // Firestore 오류 시 Mock 캐시만 확인
          if (_mockUserCache.containsKey(uid)) {
            return _mockUserCache[uid];
          }
        }
      }
      
      return null;
    } catch (e) {
      // Mock 캐시에 있으면 반환
      if (_mockUserCache.containsKey(uid)) {
        return _mockUserCache[uid];
      }
      return null;
    }
  }

  Stream<UserEntity?> getUserStream(String uid) {
    // Mock 캐시에 있으면 Mock 데이터를 스트림으로 반환
    if (_mockUserCache.containsKey(uid)) {
      return Stream.value(_mockUserCache[uid]);
    }
    
    // Firebase가 초기화된 경우에만 Firestore 스트림 사용
    if (_isFirebaseInitialized) {
      try {
        return _firestore.collection('users').doc(uid).snapshots().map(
          (doc) {
            if (doc.exists && doc.data() != null) {
              return UserEntity.fromFirestore(uid, doc.data()!);
            }
            // Mock 캐시 다시 확인 (Firestore 오류 시)
            return _mockUserCache[uid];
          },
        );
      } catch (e) {
        // Firestore 오류 시 빈 스트림 반환
        return Stream.value(null);
      }
    }
    
    // Firebase가 초기화되지 않은 경우 빈 스트림 반환
    return Stream.value(null);
  }

  Future<void> updateUserData(UserEntity user) async {
    // Mock 캐시에 업데이트
    _mockUserCache[user.uid] = user.copyWith(updatedAt: DateTime.now());
    
    // Firebase가 초기화된 경우에만 Firestore 업데이트
    if (_isFirebaseInitialized) {
      try {
        final updatedUser = user.copyWith(updatedAt: DateTime.now());
        await _firestore
            .collection('users')
            .doc(user.uid)
            .update(updatedUser.toFirestore());
      } catch (e) {
        // Firestore 오류는 무시하고 Mock만 업데이트
      }
    }
  }

  Future<void> _createUserDocument(UserEntity user) async {
    // Mock 캐시에 저장
    _mockUserCache[user.uid] = user;
    
    // Firebase가 초기화된 경우에만 Firestore에 저장
    if (_isFirebaseInitialized) {
      try {
        await _firestore
            .collection('users')
            .doc(user.uid)
            .set(user.toFirestore());

        if (user.userType == UserType.provider) {
          await _firestore.collection('providers').doc(user.uid).set({
            'createdAt': Timestamp.fromDate(user.createdAt),
            'updatedAt': Timestamp.fromDate(user.updatedAt),
            'verificationStatus': 'pending',
            'stats': {
              'totalMissions': 0,
              'activeMissions': 0,
              'completedMissions': 0,
              'totalSpent': 0,
              'averageRating': 0.0,
              'totalTesters': 0,
            },
          });
      } else {
        await _firestore.collection('testers').doc(user.uid).set({
          'experience': {
            'level': 'beginner',
            'yearsOfExperience': 0,
            'totalMissionsCompleted': 0,
            'specializations': <String>[],
          },
          'devices': <Map<String, dynamic>>[],
          'earnings': {
            'totalEarned': 0,
            'availableBalance': 0,
            'pendingBalance': 0,
          },
          'rating': {
            'average': 0.0,
            'totalReviews': 0,
            'breakdown': {
              'communication': 0.0,
              'quality': 0.0,
              'timeliness': 0.0,
              'thoroughness': 0.0,
            },
          },
          'availability': {
            'status': 'available',
            'preferredHours': {
              'start': '09:00',
              'end': '18:00',
            },
            'maxConcurrentMissions': 3,
          },
          'verificationStatus': 'pending',
          'createdAt': Timestamp.fromDate(user.createdAt),
          'updatedAt': Timestamp.fromDate(user.updatedAt),
        });
      }
    } catch (e) {
      rethrow;
    }
  }

  Future<void> _updateLastLoginTime(String uid) async {
    try {
      await _firestore.collection('users').doc(uid).update({
        'lastLoginAt': Timestamp.fromDate(DateTime.now()),
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      });
    } catch (e) {
      rethrow;
    }
  }

  Future<void> deleteAccount() async {
    try {
      final user = _firebaseAuth.currentUser;
      if (user != null) {
        await _firestore.collection('users').doc(user.uid).update({
          'isActive': false,
          'deletedAt': Timestamp.fromDate(DateTime.now()),
          'updatedAt': Timestamp.fromDate(DateTime.now()),
        });
        
        await user.delete();
      }
    } catch (e) {
      rethrow;
    }
  }

  // Mock 로그인 계정들 (Firestore API 미활성화 상태에서 사용)
  static const Map<String, Map<String, dynamic>> _mockAccounts = {
    // 관리자 계정 1 - TechCorp 대표
    'admin@techcorp.com': {
      'uid': 'mock_admin_001',
      'email': 'admin@techcorp.com',
      'password': 'admin123',
      'displayName': '김관리자',
      'userType': 'provider',
      'companyName': 'TechCorp Ltd.',
      'country': 'KR',
      'phoneNumber': '+82-10-1234-5678',
      'photoUrl': 'https://i.pravatar.cc/150?img=1',
    },
    
    // 관리자 계정 2 - GameStudio 대표  
    'provider@gamestudio.com': {
      'uid': 'mock_admin_002',
      'email': 'provider@gamestudio.com', 
      'password': 'game123',
      'displayName': '박게임스',
      'userType': 'provider',
      'companyName': 'GameStudio Inc.',
      'country': 'KR',
      'phoneNumber': '+82-10-9876-5432',
      'photoUrl': 'https://i.pravatar.cc/150?img=2',
    },
    
    // 관리자 계정 3 - FinTech 대표
    'ceo@fintech.co.kr': {
      'uid': 'mock_admin_003',
      'email': 'ceo@fintech.co.kr',
      'password': 'fin123',
      'displayName': '이핀테크',
      'userType': 'provider', 
      'companyName': 'FinTech Solutions',
      'country': 'KR',
      'phoneNumber': '+82-10-1111-2222',
      'photoUrl': 'https://i.pravatar.cc/150?img=3',
    },

    // 테스터 계정 1 - 베테랑 테스터
    'tester@bugcash.com': {
      'uid': 'mock_tester_001',
      'email': 'tester@bugcash.com',
      'password': 'test123', 
      'displayName': '김테스터',
      'userType': 'tester',
      'country': 'KR',
      'phoneNumber': '+82-10-5555-6666',
      'photoUrl': 'https://i.pravatar.cc/150?img=4',
      'level': 'expert',
      'totalPoints': 25800,
      'completedMissions': 142,
    },
    
    // 테스터 계정 2 - 중급 테스터
    'user@example.com': {
      'uid': 'mock_tester_002', 
      'email': 'user@example.com',
      'password': 'user123',
      'displayName': '이유저',
      'userType': 'tester',
      'country': 'KR',
      'phoneNumber': '+82-10-7777-8888',
      'photoUrl': 'https://i.pravatar.cc/150?img=5',
      'level': 'intermediate',
      'totalPoints': 8950,
      'completedMissions': 47,
    },
    
    // 테스터 계정 3 - 초보 테스터
    'newbie@test.com': {
      'uid': 'mock_tester_003',
      'email': 'newbie@test.com', 
      'password': 'new123',
      'displayName': '박초보',
      'userType': 'tester',
      'country': 'KR',
      'phoneNumber': '+82-10-3333-4444',
      'photoUrl': 'https://i.pravatar.cc/150?img=6',
      'level': 'beginner',
      'totalPoints': 1200,
      'completedMissions': 5,
    },

    // 테스터 계정 4 - 모바일 전문가
    'mobile@expert.com': {
      'uid': 'mock_tester_004',
      'email': 'mobile@expert.com',
      'password': 'mobile123', 
      'displayName': '최모바일',
      'userType': 'tester',
      'country': 'KR',
      'phoneNumber': '+82-10-9999-0000',
      'photoUrl': 'https://i.pravatar.cc/150?img=7',
      'level': 'advanced',
      'totalPoints': 18750,
      'completedMissions': 89,
      'specialization': ['Android', 'iOS', 'React Native'],
    },
  };

  Future<bool> _isMockAccount(String email) async {
    return _mockAccounts.containsKey(email);
  }

  Future<UserCredential> _mockSignIn(String email, String password) async {
    final mockAccount = _mockAccounts[email];
    if (mockAccount == null) {
      throw FirebaseAuthException(
        code: 'user-not-found',
        message: 'Mock 계정을 찾을 수 없습니다.',
      );
    }

    if (mockAccount['password'] != password) {
      throw FirebaseAuthException(
        code: 'wrong-password', 
        message: '비밀번호가 일치하지 않습니다.',
      );
    }

    // Mock User 생성
    final mockUser = _MockUser(
      uid: mockAccount['uid']!,
      email: mockAccount['email']!,
      displayName: mockAccount['displayName']!,
      photoURL: mockAccount['photoUrl'],
    );

    // Mock UserCredential 생성
    final mockCredential = _MockUserCredential(user: mockUser);
    
    // UserEntity 생성 및 메모리 캐시에 저장
    final now = DateTime.now();
    final userEntity = UserEntity(
      uid: mockUser.uid,
      email: mockUser.email!,
      displayName: mockUser.displayName!,
      photoUrl: mockUser.photoURL,
      userType: mockAccount['userType'] == 'provider' ? UserType.provider : UserType.tester,
      phoneNumber: mockAccount['phoneNumber'],
      country: mockAccount['country']!,
      timezone: DateTime.now().timeZoneName,
      createdAt: now,
      updatedAt: now, 
      lastLoginAt: now,
    );

    // Mock 사용자 데이터를 메모리 캐시에 저장
    _mockUserCache[mockUser.uid] = userEntity;
    
    // Mock 현재 사용자 설정
    _mockCurrentUser = mockUser;
    
    // Mock auth controller에 새 사용자 알림
    _mockAuthController.add(mockUser);

    return mockCredential;
  }

  // Mock 계정 목록 조회 (디버그용)
  static Map<String, String> getMockAccountList() {
    final accounts = <String, String>{};
    _mockAccounts.forEach((email, data) {
      accounts[email] = '${data['displayName']} (${data['userType']})';
    });
    return accounts;
  }
}

// Mock User 클래스
class _MockUser implements User {
  @override
  final String uid;
  
  @override
  final String? email;
  
  @override
  final String? displayName;
  
  @override
  final String? photoURL;

  _MockUser({
    required this.uid,
    required this.email,
    required this.displayName,
    this.photoURL,
  });

  @override
  bool get emailVerified => true;

  @override
  UserMetadata get metadata => throw UnimplementedError();

  @override
  String? get phoneNumber => null;

  @override
  List<UserInfo> get providerData => [];

  @override
  String? get refreshToken => null;

  @override
  String? get tenantId => null;

  @override
  bool get isAnonymous => false;

  @override
  Future<void> delete() async {}

  @override
  Future<String> getIdToken([bool forceRefresh = false]) async => 'mock-token';

  @override
  Future<IdTokenResult> getIdTokenResult([bool forceRefresh = false]) async => throw UnimplementedError();

  @override
  Future<UserCredential> linkWithCredential(AuthCredential credential) async => throw UnimplementedError();

  @override
  Future<ConfirmationResult> linkWithPhoneNumber(String phoneNumber, [RecaptchaVerifier? verifier]) async => throw UnimplementedError();

  @override
  Future<UserCredential> linkWithPopup(AuthProvider provider) async => throw UnimplementedError();

  @override
  Future<void> linkWithRedirect(AuthProvider provider) async => throw UnimplementedError();

  @override
  Future<UserCredential> reauthenticateWithCredential(AuthCredential credential) async => throw UnimplementedError();

  @override
  Future<UserCredential> reauthenticateWithPopup(AuthProvider provider) async => throw UnimplementedError();

  @override
  Future<void> reauthenticateWithRedirect(AuthProvider provider) async => throw UnimplementedError();

  @override
  Future<void> reload() async {}

  @override
  Future<void> sendEmailVerification([ActionCodeSettings? actionCodeSettings]) async {}

  @override
  Future<User> unlink(String providerId) async => throw UnimplementedError();

  @override
  Future<void> updateDisplayName(String? displayName) async {}

  @override
  Future<void> updateEmail(String newEmail) async {}

  @override
  Future<void> updatePassword(String newPassword) async {}

  @override
  Future<void> updatePhoneNumber(PhoneAuthCredential phoneCredential) async {}

  @override
  Future<void> updatePhotoURL(String? photoURL) async {}

  @override
  Future<void> updateProfile({String? displayName, String? photoURL}) async {}

  @override
  Future<void> verifyBeforeUpdateEmail(String newEmail, [ActionCodeSettings? actionCodeSettings]) async {}

  @override
  MultiFactor get multiFactor => throw UnimplementedError();

  @override
  Future<UserCredential> linkWithProvider(AuthProvider provider) async => throw UnimplementedError();

  @override
  Future<UserCredential> reauthenticateWithProvider(AuthProvider provider) async => throw UnimplementedError();
}

// Mock UserCredential 클래스  
class _MockUserCredential implements UserCredential {
  @override
  final User? user;

  _MockUserCredential({required this.user});

  @override
  AdditionalUserInfo? get additionalUserInfo => null;

  @override
  AuthCredential? get credential => null;
}
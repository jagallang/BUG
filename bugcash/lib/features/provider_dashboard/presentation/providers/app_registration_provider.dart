import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'dart:io';
import '../providers/provider_dashboard_provider.dart';
import '../../domain/models/provider_model.dart';
import '../../domain/repositories/provider_dashboard_repository.dart';

// App registration state
class AppRegistrationState {
  final bool isLoading;
  final String? error;
  final double uploadProgress;
  final AppRegistrationStep currentStep;

  const AppRegistrationState({
    this.isLoading = false,
    this.error,
    this.uploadProgress = 0.0,
    this.currentStep = AppRegistrationStep.basicInfo,
  });

  AppRegistrationState copyWith({
    bool? isLoading,
    String? error,
    double? uploadProgress,
    AppRegistrationStep? currentStep,
  }) {
    return AppRegistrationState(
      isLoading: isLoading ?? this.isLoading,
      error: error,
      uploadProgress: uploadProgress ?? this.uploadProgress,
      currentStep: currentStep ?? this.currentStep,
    );
  }
}

enum AppRegistrationStep {
  basicInfo,
  detailedInfo,
  mediaFiles,
  review,
  submitted,
}

// App registration notifier
class AppRegistrationNotifier extends StateNotifier<AppRegistrationState> {
  final ProviderDashboardRepository _repository;
  final FirebaseStorage _storage = FirebaseStorage.instance;

  AppRegistrationNotifier(this._repository) : super(const AppRegistrationState());

  // Submit app registration
  Future<void> submitApp(Map<String, dynamic> appData) async {
    state = state.copyWith(isLoading: true, error: null);

    try {
      // Step 1: Upload files to Firebase Storage
      final uploadedFiles = await _uploadFiles(appData);
      
      // Step 2: Create app model with uploaded file URLs
      final appModel = _createAppModel(appData, uploadedFiles);
      
      // Step 3: Submit to repository
      await _repository.createApp(appModel);
      
      state = state.copyWith(
        isLoading: false, 
        currentStep: AppRegistrationStep.submitted,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
      rethrow;
    }
  }

  // Upload files to Firebase Storage
  Future<Map<String, String>> _uploadFiles(Map<String, dynamic> appData) async {
    final Map<String, String> uploadedUrls = {};
    final String providerId = appData['providerId'];
    final String packageName = appData['packageName'];
    final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();

    // Upload app icon
    if (appData['appIconFile'] != null) {
      final File iconFile = appData['appIconFile'];
      final String iconPath = 'apps/$providerId/$packageName/icon_$timestamp.png';
      final String iconUrl = await _uploadFile(iconFile, iconPath);
      uploadedUrls['iconUrl'] = iconUrl;
    }

    // Upload screenshots
    if (appData['screenshotFiles'] != null) {
      final List<File> screenshotFiles = appData['screenshotFiles'];
      final List<String> screenshotUrls = [];
      
      for (int i = 0; i < screenshotFiles.length; i++) {
        final String screenshotPath = 'apps/$providerId/$packageName/screenshots/screenshot_${i}_$timestamp.png';
        final String screenshotUrl = await _uploadFile(screenshotFiles[i], screenshotPath);
        screenshotUrls.add(screenshotUrl);
      }
      uploadedUrls['screenshotUrls'] = screenshotUrls.join(',');
    }

    // Upload app binary
    if (appData['appBinaryFile'] != null) {
      final File binaryFile = appData['appBinaryFile'];
      final String extension = _getFileExtension(appData['type']);
      final String binaryPath = 'apps/$providerId/$packageName/binary/app_$timestamp.$extension';
      final String binaryUrl = await _uploadFile(binaryFile, binaryPath);
      uploadedUrls['binaryUrl'] = binaryUrl;
    }

    return uploadedUrls;
  }

  // Upload individual file
  Future<String> _uploadFile(File file, String path) async {
    try {
      final Reference ref = _storage.ref().child(path);
      final UploadTask uploadTask = ref.putFile(file);

      // Monitor upload progress
      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {
        final double progress = snapshot.bytesTransferred / snapshot.totalBytes;
        state = state.copyWith(uploadProgress: progress);
      });

      final TaskSnapshot snapshot = await uploadTask;
      return await snapshot.ref.getDownloadURL();
    } catch (e) {
      throw Exception('파일 업로드 실패: ${e.toString()}');
    }
  }

  // Create app model from form data
  AppModel _createAppModel(Map<String, dynamic> appData, Map<String, String> uploadedFiles) {
    return AppModel(
      id: '', // Will be generated by Firestore
      providerId: appData['providerId'],
      appName: appData['appName'],
      packageName: appData['packageName'],
      version: appData['version'],
      description: appData['description'],
      shortDescription: appData['shortDescription'],
      developer: appData['developer'],
      contactEmail: appData['email'],
      website: appData['website'],
      privacyPolicyUrl: appData['privacyPolicy'],
      category: appData['category'],
      type: appData['type'],
      contentRating: appData['contentRating'],
      targetAge: appData['targetAge'],
      isFreemium: appData['isFreemium'],
      containsAds: appData['containsAds'],
      requiresPermissions: appData['requiresPermissions'],
      keywords: _parseKeywords(appData['keywords']),
      iconUrl: uploadedFiles['iconUrl'],
      screenshotUrls: _parseScreenshotUrls(uploadedFiles['screenshotUrls']),
      binaryUrl: uploadedFiles['binaryUrl'],
      releaseNotes: appData['releaseNotes'],
      status: AppStatus.review, // Start in review status
      averageRating: 0.0,
      totalRatings: 0,
      totalDownloads: 0,
      totalTesters: 0,
      totalMissions: 0,
      activeMissions: 0,
      completedMissions: 0,
      totalBugReports: 0,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      metadata: const {},
    );
  }

  // Helper methods
  String _getFileExtension(AppType type) {
    switch (type) {
      case AppType.android:
        return 'apk';
      case AppType.ios:
        return 'ipa';
      case AppType.web:
        return 'zip';
      case AppType.desktop:
        return 'exe';
    }
  }

  List<String> _parseKeywords(String? keywordsString) {
    if (keywordsString == null || keywordsString.trim().isEmpty) {
      return [];
    }
    return keywordsString
        .split(',')
        .map((keyword) => keyword.trim())
        .where((keyword) => keyword.isNotEmpty)
        .toList();
  }

  List<String> _parseScreenshotUrls(String? screenshotUrlsString) {
    if (screenshotUrlsString == null || screenshotUrlsString.trim().isEmpty) {
      return [];
    }
    return screenshotUrlsString
        .split(',')
        .where((url) => url.trim().isNotEmpty)
        .toList();
  }

  // Update registration step
  void updateStep(AppRegistrationStep step) {
    state = state.copyWith(currentStep: step);
  }

  // Clear error
  void clearError() {
    state = state.copyWith(error: null);
  }

  // Reset state
  void reset() {
    state = const AppRegistrationState();
  }
}

// Providers
final appRegistrationProvider = StateNotifierProvider<AppRegistrationNotifier, AppRegistrationState>((ref) {
  final repository = ref.watch(providerDashboardRepositoryProvider);
  return AppRegistrationNotifier(repository);
});

// App validation provider
final appValidationProvider = Provider.family<AppValidationResult, Map<String, dynamic>>((ref, appData) {
  return _validateAppData(appData);
});

// App validation result
class AppValidationResult {
  final bool isValid;
  final List<String> errors;
  final List<String> warnings;

  const AppValidationResult({
    required this.isValid,
    required this.errors,
    required this.warnings,
  });
}

// App validation logic
AppValidationResult _validateAppData(Map<String, dynamic> appData) {
  final List<String> errors = [];
  final List<String> warnings = [];

  // Required fields validation
  if (appData['appName'] == null || appData['appName'].toString().trim().isEmpty) {
    errors.add('앱 이름은 필수입니다');
  }

  if (appData['packageName'] == null || appData['packageName'].toString().trim().isEmpty) {
    errors.add('패키지명은 필수입니다');
  } else {
    final packageName = appData['packageName'].toString();
    final regex = RegExp(r'^[a-z][a-z0-9_]*(\.[a-z][a-z0-9_]*)+$');
    if (!regex.hasMatch(packageName)) {
      errors.add('올바른 패키지명 형식이 아닙니다');
    }
  }

  if (appData['version'] == null || appData['version'].toString().trim().isEmpty) {
    errors.add('버전은 필수입니다');
  } else {
    final version = appData['version'].toString();
    final regex = RegExp(r'^\d+\.\d+\.\d+$');
    if (!regex.hasMatch(version)) {
      errors.add('올바른 버전 형식이 아닙니다 (예: 1.0.0)');
    }
  }

  if (appData['description'] == null || appData['description'].toString().trim().isEmpty) {
    errors.add('상세 설명은 필수입니다');
  } else if (appData['description'].toString().length < 50) {
    errors.add('상세 설명은 최소 50글자 이상이어야 합니다');
  }

  if (appData['developer'] == null || appData['developer'].toString().trim().isEmpty) {
    errors.add('개발자명은 필수입니다');
  }

  if (appData['email'] == null || appData['email'].toString().trim().isEmpty) {
    errors.add('연락처 이메일은 필수입니다');
  } else {
    final email = appData['email'].toString();
    final regex = RegExp(r'^[^@]+@[^@]+\.[^@]+$');
    if (!regex.hasMatch(email)) {
      errors.add('올바른 이메일 형식이 아닙니다');
    }
  }

  // File validation
  if (appData['appIconFile'] == null) {
    errors.add('앱 아이콘은 필수입니다');
  }

  if (appData['screenshotFiles'] == null || (appData['screenshotFiles'] as List).length < 2) {
    errors.add('최소 2개의 스크린샷이 필요합니다');
  }

  if (appData['appBinaryFile'] == null) {
    errors.add('앱 파일은 필수입니다');
  }

  // Warnings
  if (appData['website'] == null || appData['website'].toString().trim().isEmpty) {
    warnings.add('웹사이트 URL을 추가하면 사용자 신뢰도가 높아집니다');
  }

  if (appData['privacyPolicy'] == null || appData['privacyPolicy'].toString().trim().isEmpty) {
    if (appData['requiresPermissions'] == true) {
      warnings.add('권한을 요구하는 앱은 개인정보처리방침이 권장됩니다');
    }
  }

  if (appData['keywords'] == null || appData['keywords'].toString().trim().isEmpty) {
    warnings.add('키워드를 추가하면 검색 노출이 향상됩니다');
  }

  return AppValidationResult(
    isValid: errors.isEmpty,
    errors: errors,
    warnings: warnings,
  );
}

// App categories provider for dropdowns
final appCategoriesProvider = Provider<List<AppCategory>>((ref) {
  return AppCategory.values;
});

// App types provider for dropdowns
final appTypesProvider = Provider<List<AppType>>((ref) {
  return AppType.values;
});

// Content ratings provider for dropdowns
final contentRatingsProvider = Provider<List<ContentRating>>((ref) {
  return ContentRating.values;
});

// File size validator
final fileSizeValidatorProvider = Provider<bool Function(File, int)>((ref) {
  return (File file, int maxSizeInMB) {
    final int fileSizeInBytes = file.lengthSync();
    final int maxSizeInBytes = maxSizeInMB * 1024 * 1024;
    return fileSizeInBytes <= maxSizeInBytes;
  };
});

// Image dimensions validator
final imageDimensionsValidatorProvider = Provider<Future<bool> Function(File, int, int)>((ref) {
  return (File imageFile, int requiredWidth, int requiredHeight) async {
    // This would require an image processing package like 'image'
    // For now, we'll return true as a placeholder
    return true;
  };
});

// Package name uniqueness checker
final packageNameCheckerProvider = FutureProvider.family<bool, String>((ref, packageName) async {
  try {
    // Check if package name already exists
    // This would require a new method in the repository
    // For now, we'll simulate the check
    await Future.delayed(const Duration(seconds: 1));
    
    // Simulate some package names being taken
    final takenNames = [
      'com.example.test',
      'com.mycompany.myapp',
      'com.demo.sample',
    ];
    
    return !takenNames.contains(packageName);
  } catch (e) {
    return true; // Default to available on error
  }
});

// App store info fetcher (for auto-filling)
final appStoreInfoProvider = FutureProvider.family<AppStoreInfo?, String>((ref, packageName) async {
  try {
    // This would integrate with app store APIs to fetch existing app info
    // For now, we'll return null as a placeholder
    await Future.delayed(const Duration(seconds: 2));
    return null;
  } catch (e) {
    return null;
  }
});

// App store info model
class AppStoreInfo {
  final String appName;
  final String description;
  final String developer;
  final List<String> screenshotUrls;
  final String iconUrl;
  final double rating;
  final int reviewCount;
  final String category;

  const AppStoreInfo({
    required this.appName,
    required this.description,
    required this.developer,
    required this.screenshotUrls,
    required this.iconUrl,
    required this.rating,
    required this.reviewCount,
    required this.category,
  });
}